<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | alex kuang]]></title>
  <link href="http://alexkuang.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://alexkuang.github.io/"/>
  <updated>2014-10-18T20:55:34-04:00</updated>
  <id>http://alexkuang.github.io/</id>
  <author>
    <name><![CDATA[Alex Kuang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[asciinema]]></title>
    <link href="http://alexkuang.github.io/blog/2014/07/16/asciinema/"/>
    <updated>2014-07-16T15:40:00-04:00</updated>
    <id>http://alexkuang.github.io/blog/2014/07/16/asciinema</id>
    <content type="html"><![CDATA[<p>I was tooling around the other day and discovered a service called <a href="https://asciinema.org">asciinema</a> which provides
terminalcasts&mdash;essentially, &ldquo;screencasts&rdquo; with terminal I/O.  This is awesome for a few reasons.</p>

<p>From a content consumer&rsquo;s standpoint, it&rsquo;s often hard to follow a blog post that&rsquo;s trying to outline a command line tip,
or a vim tip, for the simple fact that the static nature of writing alone isn&rsquo;t optimal for showing the flow between
&ldquo;steps&rdquo; (commands, keystrokes, what have you) and &ldquo;output&rdquo; (what you&rsquo;re supposed to see after executing commands).
Having a dynamic format for demos helps with this greatly.  Sure, there are screencasts, but that involves dealing with
videos and their associated heavy Flash Player bullshit.  asciinema is rendered with just bits of html and js.</p>

<p>From a wannabe content producer&rsquo;s standpoint&hellip;  Writing is <em>hard</em>.  Writing while crafting appropriate examples is
harder.  Doing all that while struggling with capturing the nature of the examples in plain text?  No thanks.
Again&mdash;Yes, there is the option of screencasts, but those are painful to set up.  Screencasts means worrying about
things like capturing software, background audio, What Tab Do I Have Open In My Browser, and Will Video Compression
Screw My Text Legibility.  As a consummately lazy person who only wants to do short self-contained clips for now&hellip;
That&rsquo;s way too big of a barrier.  asciinema is easy&mdash;Just install, then <code>asciinema rec</code> from the terminal and <code>&lt;CTRL-D&gt;</code>
to exit and upload.</p>

<p>And embedding takes 2 seconds&mdash;Check it!</p>

<script type="text/javascript" src="https://asciinema.org/a/10785.js" id="asciicast-10785" async></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bracket Expansion in the Shell]]></title>
    <link href="http://alexkuang.github.io/blog/2014/06/25/bracket-expansion-in-the-shell/"/>
    <updated>2014-06-25T18:58:00-04:00</updated>
    <id>http://alexkuang.github.io/blog/2014/06/25/bracket-expansion-in-the-shell</id>
    <content type="html"><![CDATA[<p>Just a quick post to show of a neat little trick for those who are more command-line-driven: bracket expansion.</p>

<p>Basically, bracket expansion means that <code>some-string-called-{x,y}-here</code> desugars in the shell to
<code>some-string-called-x-here some-string-called-y-here</code>.  This is especially useful if, say, you&rsquo;re in a Java-like
directory structure and you accidentally placed your source class in your test folder, and you need to move it back:</p>

<p>```bash</p>

<h1>desugars into mv src/test/java/com/foobar/app/Class.java src/main/java/com/foobar/app/Class.java</h1>

<p>mv src/{test,main}/java/com/foobar/app/Class.java
```</p>

<p>Or if you&rsquo;ve already committed to source control, this also works quite nicely with <code>git mv</code>.  Another nice example from
recent memory is, say, if you were cleaning up some directories nested by date and wanted to only wipe a few months:</p>

<p><code>bash
rm /posts/2014/{01,03,06,07}/*.html
</code></p>

<p>Anyway, just a quick little post for a neat little trick.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, Hardware World!]]></title>
    <link href="http://alexkuang.github.io/blog/2014/06/14/hello-hardware-world/"/>
    <updated>2014-06-14T16:56:00-04:00</updated>
    <id>http://alexkuang.github.io/blog/2014/06/14/hello-hardware-world</id>
    <content type="html"><![CDATA[<p>Recently, one of our tech leads at work previewed <a href="https://github.com/ogrodnek/analog-metrics-talk">a talk</a> that he&rsquo;s
planning to give on analog metrics for the upcoming Strange Loop conference.  I&rsquo;ve always wanted to play with
microcontrollers, and this really gave me a kick in the pants to get started.  Since I had a bit of amazon credit lying
around, I decided to buy an arduino starter kit with all sorts of buttons, lights, and doo-dads, but not enough power to
actually fry anything (I hope).  I still can&rsquo;t tell my head from my ass, but so far I can make a button turn on an LED.</p>

<p><img class="center <a" src="href="http://waffleparadox.smugmug.com/Other/Camera-Awesome-Photos/i-h59QFDb/0/L/CA_06051420063663-L.jpg">http://waffleparadox.smugmug.com/Other/Camera-Awesome-Photos/i-h59QFDb/0/L/CA_06051420063663-L.jpg</a>"></p>

<p>Next step: world domination!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hack Days Are Awesome]]></title>
    <link href="http://alexkuang.github.io/blog/2014/04/26/hack-days-are-awesome/"/>
    <updated>2014-04-26T15:32:00-04:00</updated>
    <id>http://alexkuang.github.io/blog/2014/04/26/hack-days-are-awesome</id>
    <content type="html"><![CDATA[<p>Earlier this week, we had a &ldquo;hack day&rdquo; at work.  Or more precisely, two hack days.  I think the name is pretty
self-explanatory&mdash;work on whatever you want, which can be something helpful to or completely unrelated to your currently
assigned tasks, as long as it&rsquo;s something interesting.  Now, &ldquo;hack time&rdquo; is a pretty established institution in the
software world, especially amongst the hip startuppy companies.  I&rsquo;m sure everyone has heard of Google&rsquo;s &ldquo;20% time&rdquo; idea
by now, and the story of Microsoft&rsquo;s Xbox starting as a side-project.  Proponents (especially those who are trying to
pitch a business case to managers with varying degrees of pointy-haired-ness) cite building camaraderie, stimulating
creativity, and increasing morale as some of the biggest benefits.</p>

<p>None of this is news.  But I came away this week with a surprising realization.  When coding professionally for business
use cases, things like resilience and stability are often at the top of the requirement list&mdash;Or at least, I&rsquo;d really
hope so.  If it&rsquo;s not, kindly give me the name of your company so I know what stock to not buy ;).  To this end, coding
is never as simple as just sitting down and banging away at a keyboard.  It involves testing, discussions, design,
thinking, more testing, more thinking, and so on and so forth.</p>

<p>Don&rsquo;t get me wrong.  These are all very, very good things.  But I, at least, was surprised at how nice it was to just
sit down and bang away at a keyboard with abandon.  It sounds rather obvious in hindsight, but compared to the usual
rigorously managed process of software development at work, it&rsquo;s super liberating to just cowboy out some code with no
considerations other than speed and getting the job done.  And what&rsquo;s more, I realized that I had constrained myself to
the same careful management in all of my personal projects as well, especially when prototyping out potential MVPs and
such.  Again&mdash;Definitely a good thing, in most cases.  But after this week I&rsquo;m thinking that injecting some &ldquo;hack
day&rdquo;-ish time into my personal projects is in order, if for no reason other than to let the crazy out.</p>

<p><strong>tl;dr</strong> &ndash; Hack days are awesome.  I should do more of them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMD Misadventures - Codebase Size]]></title>
    <link href="http://alexkuang.github.io/blog/2013/12/23/cmd-misadventures-codebase-size/"/>
    <updated>2013-12-23T06:50:00-05:00</updated>
    <id>http://alexkuang.github.io/blog/2013/12/23/cmd-misadventures-codebase-size</id>
    <content type="html"><![CDATA[<p>After watching the <a href="https://www.destroyallsoftware.com/talks/wat">wat</a> talk and trolling my friends with the
<a href="https://www.destroyallsoftware.com/talks/a-whole-new-world">aneditor</a> talk for about the 200th time, I decided to
finally purchase one season of the Destroy All Software screencasts, despite the (IMHO) steep price tag and my financial
destitution.  (So far?  Totally worth it.  But a full review of the screencasts is neither here nor there.)</p>

<p>I&rsquo;ve always been a big fan of the unix power tools&mdash;<code>find</code>, <code>grep</code>, <code>xargs</code>, and so forth&mdash;but the DAS talks introduced
an idea that had never occurred to me for some insane reason: combine them with git to extract some interesting
information about your codebase.  And so, I decided to go diving into my biggest scala project for insights about its
code size.</p>

<p>One of the most common problems that code size can indicate is the presence of &ldquo;god classes&rdquo; or libraries, which know
and do way too much and thus are correspondingly bigger than the rest of the code by orders of magnitude.  This command
was relatively simple and does not involve git, so here it is in its entirety:</p>

<p>```bash
alexkuang@Orion [00:00:00] [~foobar/src/main/scala] [master]
&ndash;> % find . -type f -name &ldquo;*.scala&rdquo; | while read file; do wc -l $file; done | sort -n</p>

<pre><code>   9 ./com/foobar/models/Permission.scala
  11 ./com/foobar/util/LocParams.scala
  14 ./com/foobar/util/OrgSettings.scala
  16 ./com/foobar/security/package.scala
  17 ./com/foobar/scripts/ReloadStageDB.scala
  18 ./com/foobar/scripts/oneoff/InitSchema.scala
  # ...
 231 ./com/foobar/js/Calendar.scala
 247 ./com/foobar/persistence/Access.scala
 287 ./com/foobar/snippet/BookingCalendar.scala
 307 ./com/foobar/lib/Registration.scala
 319 ./com/foobar/lib/Scheduler.scala
</code></pre>

<p>```</p>

<p>The output was slightly interesting, but nothing groundbreaking.  300 lines is not ideal to me, but manageable.  Broken
down quickly, <code>find #...</code> finds all files inside the current directory ending in &lsquo;.scala&rsquo;, reads each file in, and
passes it off to wc -l, which does a linecount on the file, whitespace and all.  <code>sort</code> does what its name implies, with
<code>-n</code> making it sort <code>1 2 3 11</code> instead of <code>1 11 2 3</code>.  The information was slightly cool, but as a hack it&rsquo;s not very
interesting, so let&rsquo;s throw some git in there to try to get a sense of how fast the codebase has grown over time.  After
all, superlinear growth is usually indicative of a ton of repetition and therefore unnecessary code complexity.</p>

<!-- more -->


<p>First, starting with walking the git repo.  <code>git rev-list &lt;branch&gt;</code> should do what we want it to, but in the case of
larger repos it the list can get a bit unwieldy/huge.  Enter <code>awk</code>, which lets you do a bunch of neat things with your
text but most importantly has an easy variable for line number, of all things <em>(note to self: learn2awk better?)</em>, thus:
<code>awk 'NR % &lt;n&gt; == 0'</code> to get only every nth revision list.  Combine that with the same reading as above, and do a
similar scala file find with a linecount, and the command is as follows: <em>(Yes, in this particular project I dev&rsquo;d right
in master instead of using a nvie-style git-flow.  Bad developer, bad!)</em></p>

<p><code>bash
git rev-list master | awk 'NR % 20 == 0' | while read revhash; do git checkout -q $revhash | \  
&amp;&amp; find . -name '*.scala' | xargs cat | wc -l; done
</code></p>

<p>The more finicky among us might comment right about now that the command is already pretty huge and nigh unreadable if
revisited in about two weeks&mdash;and he&rsquo;d be right.  But this is a quick one-off hack for some interesting info (something
that unix tools are absolutely amazing at), and if I cared that much I&rsquo;d probably write a real script, or at least
re-format it into a proper bash function.</p>

<p>So the above command gives us a bunch of line counts which is useful, but it doesn&rsquo;t really give us a sense of the
progression.  At this point I&rsquo;d usually either 1) compose some huge complicated thing that kept track of the current
line AND the previous in an attempt to do math, or 2) give up and write a real script for it later, but one of the DAS
videos showed something that was completely new to me: using <code>jot</code> to create a chart.  Even if I learned nothing else,
this alone made everything worth it.  Very quickly&hellip;</p>

<p>```bash
&ndash;> % jot &ndash; 1 5</p>

<h1>print range 1 to 5</h1>

<p>1
2
3
4
5
&ndash;> % jot -b &lsquo;*&rsquo; &ndash; 1 5</p>

<h1>range 1 to 5, printing &lsquo;*&rsquo; instead</h1>

<p>*
*
*
*
*
&ndash;> % jot -b &lsquo;*&rsquo; &ndash; 1 5 | xargs</p>

<h1>For all its magic, xargs just chunks up your input to be used as args.</h1>

<hr />

<p>&ndash;> % jot -b &lsquo;*&rsquo; &ndash; 1 5 | xargs | tr -d &lsquo; &rsquo;</p>

<h1>And tr to translate.  Side note: as a recovering Perl user, it slightly annoys me that there&rsquo;s a tr util but not an s</h1>

<h1>util.  But I guess that&rsquo;s what sed is for&hellip;?</h1>

<hr />

<p>```</p>

<p>And now all that&rsquo;s left is to combine the <code>jot</code> magic with the above command by reading a the linecount into a variable
called <code>lines</code>, using that in the <code>jot</code> call, and printing everything out.  In the interest of full disclosure, here&rsquo;s
the final command along with the output from my project:</p>

<p><code>``bash
-&gt; % git rev-list master | awk 'NR % 20 == 0' | while read revhash; do git checkout -q $revhash &amp;&amp; \  
find . -name '*.scala' | xargs cat | wc -l | \  
read lines &amp;&amp; ((hashes = $lines / 100)) &amp;&amp; \  
echo "</code>jot -b &lsquo;#&rsquo; &ndash; 1 $hashes | xargs | tr -d &lsquo; &rsquo;` $lines"; done</p>

<h6>################################################### 5700</h6>

<h6>############################################### 5333</h6>

<h6>############################################# 5151</h6>

<h6>######################################### 4796</h6>

<h6>####################################### 4530</h6>

<h6>############################### 3786</h6>

<h6>############################# 3528</h6>

<h6>############################## 3660</h6>

<h6>############################## 3615</h6>

<h6>########################## 3208</h6>

<h6>###################### 2848</h6>

<h6>###################### 2832</h6>

<h6>###################### 2855</h6>

<h6>##################### 2786</h6>

<h6>################## 2418</h6>

<h6>############### 2186</h6>

<h6>############ 1834</h6>

<h6>########## 1664</h6>

<h6>######## 1412</h6>

<h6>###### 1270</h6>

<h6>##### 1179</h6>

<h6>## 892</h6>

<h6>651</h6>

<h4>420</h4>

<h1>138</h1>

<p>```</p>

<p>The growth at the beginning looked pretty normal, and I must say I&rsquo;m slightly happy that around the middle it remained
constant, and even took a slight dip afterwards.  After the dip though it seems like the growth started shooting up
again, which is not a good sign.  This is consistent with my personal experience, as I recall starting to really throw
in the super-hacks at around that time, so everything is probably due for another refactor.</p>

<p>In closing, I&rsquo;d like to remark that while this post was pretty monolithic and it took a lot of text to explain
everything for the first time, in real life this command probably took about 2-3 minutes to write.  And that&rsquo;s what I
find these utils are really really good at&mdash;Quick dirty answers to the little &ldquo;I wonder&hellip;&rdquo; / &ldquo;What if&hellip;&rdquo; questions
that tend to pop up while coding.</p>
]]></content>
  </entry>
  
</feed>

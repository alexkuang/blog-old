<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Totw | alex kuang]]></title>
  <link href="http://alexkuang.github.io/blog/categories/totw/atom.xml" rel="self"/>
  <link href="http://alexkuang.github.io/"/>
  <updated>2016-05-20T08:51:11-04:00</updated>
  <id>http://alexkuang.github.io/</id>
  <author>
    <name><![CDATA[Alex Kuang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Purity, Types, and Other Functional Nonsense]]></title>
    <link href="http://alexkuang.github.io/blog/2016/04/14/purity-types-functional-nonsense/"/>
    <updated>2016-04-14T07:12:23-04:00</updated>
    <id>http://alexkuang.github.io/blog/2016/04/14/purity-types-functional-nonsense</id>
    <content type="html"><![CDATA[<p>A while ago the topic of <a href="http://fluffynukeit.com/how-functional-programming-lenses-work/">lenses</a> came up in one of the
chatrooms at work. This led to a discussion on the (ahem) suboptimal readability of advanced functional programming
code examples, and how a lot of the fancier constructs are by-products of being super hardcore about purity.  This led
to me writing a great big email to the team that generated a whole bunch of thoughtful discussion on FP, complexity, and
straw men with free lunches. I was also told I should transcribe to blog form, so here it is reproduced (mostly)
faithfully:</p>




<p>I’ve been digging into Haskell/etc a bunch lately and have hit some similar pain points. Typeclasses and
Haskell-specific syntax aside, I think one of the biggest mental shifts I have experienced is learning to reason based
on types alone. Full disclaimer: I am by no means an expert on any of this. But since I am (at the original time of
writing) sitting in an airport with a mildly disgruntled cat, I figure I may as well write up a blurb about my
experiences on purity, types, and what can follow from it.</p>




<!-- more -->




<h3>A Brave New World</h3>




<p>So for the rest of this email, let’s suspend our disbelief and imagine that we have an “ideal functional” Scala that is
pure and strongly typed. This means no:</p>




<ul>
<li><code>null</code></li>
<li>exceptions</li>
<li>type-casting (e.g. <code>asInstanceOf</code>, <code>isInstanceOf</code>)</li>
<li>side-effects (e.g. <code>println</code>, <code>cw.track(metric)</code>)</li>
<li>Object (e.g. <code>anything.toString</code>)</li>
</ul>




<h3>A simple example</h3>




<p>Given the above, consider a function with this signature:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">nonsense</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p><code>nonsense</code> is parameterized on the type <code>A</code>, which could be any type. This means that the implementation of <code>nonsense</code> knows
literally nothing about its input—It could be a number, a list, an Option, a String, or anything else we can think of
passing in. Because we’re living in this imaginary world where null, etc do not exist, <code>nonsense</code> literally cannot do
anything with its argument except return it.</p>




<p>Following this logic, we can deduce that <code>nonsense</code> is just the identity function based on its type signature alone. It
doesn’t matter if it is called <code>nonsense</code> or <code>foo</code> or <code>id</code>, or if its argument is named <code>i</code>, <code>j</code>, <code>k</code>. We don’t even have to look at
the implementation. Given the type <code>A =&gt; A</code>, this function literally cannot do anything other than return its argument, or
else it would not have compiled. (Again, this is assuming no <code>null</code>, <code>println</code>, etc).</p>




<p>Extending this slightly, this function:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">c</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>can only have two possible implementations based on its type: <code>def c[A](i: A, j: A) = i</code>, or <code>def c[A](i: A, j: A) = j</code>.
Likewise, <code>def c2[A, B](i: A, j: B): B</code> can only <code>=&gt; j</code>, and so on.</p>




<h3>A structured example</h3>




<p>Now consider the function:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">nonsense2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Without looking at the function name, the implementation, and so on, what can we deduce about <code>nonsense2</code> in our imaginary
magical world? <em>The output never contains any element that was not in the input</em>. That is, the output could be the input
itself, it could be input reversed, it could be the input sliced up—but you will never have a situation where e.g.
<code>nonsense2(List(1)) == List(2)</code> or <code>nonsense2(List(1)) == List(List("XYZ"))</code>. To put it another way, just based on the type
signature of <code>List[A] =&gt; List[A]</code>, we know that the function may do something to the <code>List</code> structure but nothing will
happen to the individual <code>A</code>s&ndash;or else the code would not have compiled.</p>




<p>This type of reasoning can be applied to basically any function to derive information about it (guess what this function
is: <code>def fff[A, B](f: A =&gt; List[B], i: List[A]): List[B]</code>). By maintaining strict typing and purity, we give up the
convenience of things like side-effects and run-time type-matching. But in exchange, we get increased ability to reason
about (and have a sufficiently smart compiler prove) certain properties of our code, regardless of potentially
misleading/outdated evidence such as function names and comments. The big idea here is to 1) shift as much of the
“thinking” to the compiler as possible to reduce the potential for human error, and 2) lock as much down during
compile-time as possible to reduce the potential surface area of run-time errors.</p>




<h3>Real life</h3>




<p>Sadly, real life is messy and not everything can be proved at compile time. Even in <code>fff</code> above, the implementation could
be e.g. <code>flatMap</code> or <code>flatMap andThen reverse</code> or just <code>Nil</code>.</p>




<p>As another example, consider:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">intNonsense</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Based on the types, we can say that the potential output of <code>intNonsense</code> is constrained to the size of the set of
possible Ints; i.e., there are 2<sup>32</sup> possible outputs. Other than that though, we can’t say much about the function’s
implementation(*). It could double its input, add 1 to its input, negate its input, negate its input but only if it’s
even, and so on.</p>




<p>So what’s a programmer to do?</p>




<p>(*) - Without some fancy pants type-level probably-church-encoded something-something-something sort of programming, but
that’s a whole ‘nother can of worms that I haven’t gotten remotely close to opening&hellip;</p>




<h3>Tests!</h3>




<p>One natural reaction would be to start writing some unit tests to make sure this function does what we think it does. So
we start writing some tests:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">assert</span><span class="o">(</span><span class="n">intNonsense</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="n">assert</span><span class="o">(</span><span class="n">intNonsense</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
</span><span class='line'><span class="n">assert</span><span class="o">(</span><span class="n">intNonsense</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'><span class="n">assert</span><span class="o">(</span><span class="n">intNonsense</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>And from that we may think that <code>intNonsense == identity</code>. Except that with the above suite, the following could still
happen, and we would be wrong:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">intNonsense</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">20000</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">i</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>We could also test the totality of the mapping between input and output to intNonsense. But even for a simple <code>Int =&gt;
Int</code> function, that would be a total of 2<sup>32</sup> possible inputs, and I feel like even the most determined programmer would
give up after a couple hundred. Or maybe not, and more power to you. :)</p>




<p>One way to help with this is properties-based testing, which I think has been discussed before. Props-based testing
frameworks come in various levels of sophistication, but the basic idea is that instead of writing tests for a single
case, you write a general “property” for your function and the framework will generate a whole bunch of kinda-random
input to throw at it. As an example in <a href="https://scalacheck.org/">ScalaCheck</a>, a property for string concatenation might
look something like:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">property</span><span class="o">(</span><span class="s">&quot;startsWith&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="n">forAll</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>This is not perfect, but it still lends itself to far more robustness-per-effort when compared to individual unit tests.
In some cases, it is even more readable as far as communicating what you want to be true about your code.</p>




<p>Of course, props-based testing can be used with the most imperative mutable-state-having code, but when combined with
pure compiler-friendly code it can end up really reducing the potential for unexpected errors.</p>




<h3>Disclaimers</h3>




<p>Wrapping up, a couple of disclaimers.</p>




<p>1) If we take the idea of using types/etc in this way another step further, we might draw the conclusion that function
names and documentation are relatively meaningless next to what you can prove with the compiler. This is one argument
I’ve heard re: scalaz’s lack of concern about approachability in its API naming + docs. “We don’t need a docstring, from
the types there is only one possible implementation of this function, so it’s self-explanatory”. If we take this idea
all the way to the extreme, we might even argue that concrete names are harmful since they propagate impressions about
the code that can potentially be outdated or false. This should sound familiar to anyone who has read, say, Tony Morris.</p>




<p>FWIW, I tend to come down on the side of “why not both”? I love the idea of catching more mistakes at build-time by
fully leveraging a smart compiler and better tests, and I do agree (at least in principle) that maintaining purity also
makes composability easier. But at the same time, I don’t really see the harm in calling an argument <code>zero</code> to declare its
intentions, regardless of whether we can fully prove it in the code. To play devil’s advocate again though, I do agree
that sometimes names are vestigial and you have to depend on the types. For example, I’ve tried and failed to think of a
better name than <code>f</code> for the argument <code>A =&gt; List[B]</code> in <code>flatMap</code>.</p>




<p>2) Approaching this from another angle, one can also write code using nothing but the types, or what I like to call
“playing type jigsaw.” IMO it’s pretty fun to just write out a bunch of type signatures and almost-kinda-auto-pilot your
way through until it compiles—but it can get really meta, and I have only had limited experience in playing around with
this style of programming. The furthest I have taken it is trying to reconstruct twitter’s
<a href="https://www.youtube.com/watch?v=VVpmMfT8aYw">Stitch</a> as a natural transformation to <code>Future</code>, and most of the other
stuff I’ve played with has been small and isolated—think Project Euler style problems. Which is to say that I’ve
explored this stuff on the side, but in practice for a large enough system I have no idea if it’s e.g. just trading one
type of complexity for another. Though intuitively I feel like enterprise code (i.e., large systems, many
inputs/outputs, lots of complex logic) is where leveraging a strongly typed functional style with a smart compiler could
really be useful in the long run.</p>




<h3>Takeaways</h3>




<p>Funnily enough, the most widely actionable takeaway from all of this is completely unrelated to types and naming and all
of that. The one thing I feel that everyone can benefit from immediately is to use more quickcheck/properties-based
testing. While it is not perfect, it sure beats enumerating things on a case-by-case basis. Plus&ndash;I forget where I read
this&ndash;“nothing scares bugs out of your code like having something feed it pathologically bad values”.</p>




<p>Aside from that&hellip; I am not immediately hopping onto the HARDCORE PURITY train, but hopefully this at least gives some
food for thought as far as another approach to writing and thinking about code.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[`gn` in Vim]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/gn-in-vim/"/>
    <updated>2015-01-24T11:53:51-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/gn-in-vim</id>
    <content type="html"><![CDATA[<p>Back to vim this week!  This one might be a bit esoteric&ndash;apologies in advance&ndash;but it’s such a useful feature that I
had to share.</p>




<p><code>gn</code> is a kinda-sorta-but-not-really-motion that selects the matches of the current search pattern.  It’s kind of like
<code>n</code> (go to next match in search), except it also selects the contents of the match in visual mode.  But where it really
shines is when used with operators like <code>c</code> (change), etc to operate on the match.  Quick demo to see it in action,
before continuing:</p>




<script type="text/javascript" src="https://asciinema.org/a/15656.js" id="asciicast-15656" async></script>




<p>So this is nice for a few reasons.  First, it’s neat to be able to operate on just the match of a search.  I remember a
few times before I found <code>gn</code> where I was doing something similar to the demo, tried to use <code>cw</code>, and got mildly annoyed
that I had to retype half the word because the <code>w</code> motion was too aggressive.</p>




<p>Another nice thing is that with <code>gn</code>, the dot command will both move to the next match and repeat whatever operation you
did, instead of having to do the movement and operation separately using <code>n.</code>.  It seems petty, but hey it’s a full 50%
keystroke savings!!</p>




<p>Arguably, the demo above could have been done with an ex command like <code>:%s/test/actual</code> (universal search and replace),
but I think <code>gn</code> still offers a lot.  It works on all operators, so <code>ygn</code> would yank the match, <code>gUgn</code> would uppercase
the match, and so on.  Plus, it allows an easy on-the-fly workflow that’s still decently fast without the “crap I have
to tune all the edge cases in my expression”: for example, if you want to only change some instances of <code>test</code> to
<code>actual</code>, but others to <code>sandbox</code>.</p>




<p>As always, see <code>:h gn</code> for more details.  Also note that gn has only been available since vim 7.4 or something like
that, but there’s no reason anyone shouldn’t be using the latest on their personal boxes…</p>




<h3>Bonus</h3>




<p>This email also generated some additional discussion, which led to my discovery of the multi-select feature in Sublime,
and the <a href="https://github.com/terryma/vim-multiple-cursors">associated vim plugin</a>.  It seems like it&rsquo;s in a different
spirit than <code>gn</code>, but still a very cool way of thinking about operating on search results that I had not seen before.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread Macro]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/thread-macro/"/>
    <updated>2015-01-24T11:53:42-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/thread-macro</id>
    <content type="html"><![CDATA[<p>Let’s deviate from Scala for a bit and talk about clojure.  Or lisps in general, I guess.  A lot of the “kinda joking
except not really” quips that commonly float around on the internet are about the parentheses, as in how there are so
many of them.  For example, if you want to take a number <code>x</code> and add one, multiply by two, then add 3, the code might
naively look something like this:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Or perhaps like this:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Look at the parens!  Especially the consecutive 3 closing ones in the second variation.  For a sufficiently long chain
of functions, it can get pretty unreadable—especially with multiple arguments and whatnot.</p>




<p>Enter clojure’s thread macro.  The thread macro is a macro in the form of <code>(-&gt; x &amp; forms)</code>, and it “threads” <code>x</code> through
the <code>forms</code> as the first arg*.  Which sounds terribly confusing explained, so an example is probably better here.  Take
this snippet using the thread macro:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; add one, multiply by two, and add three</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">x</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">* </span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>This desugars into <code>(+ (* (+ x 1) 2) 3)</code>, i.e. the first variation of the initial example above.  Personally, I find the
macro version much more readable since each call is on its own line, and it seems more expressive of applying a series
of functions to the initial x.</p>




<p>The thread macro is also useful for chaining together collection methods like <code>map</code>.  Since clojure doesn’t have
first-class OO support (instead favoring protocols and such), map exists as a regular function that takes the collection
as an arg, instead of as a method on a collection class.  So chaining together a bunch of ops on a vector might look
something like&hellip;</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; add one to every number and filter for even numbers</span>
</span><span class='line'><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; Without the thread macro, would look like:</span>
</span><span class='line'><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">%</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>The only difference is that in this case, ->> was used.  ->> is “thread last”, which is like -> (“thread first”), except
it inserts the expression at the end of the form.</p>




<p>This pattern also exists in other languages (especially those that don’t offer first-class OO, which allows fancy
<code>return self</code> type stuff), like Elixir’s pipe <code>|&gt;</code> (in the spirit of the unix pipe) which is what prompted me to spread
the word about this:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="c1"># double and add one to each element</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="o">|&gt;</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="k">fn</span> <span class="n">x</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="o">|&gt;</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="k">fn</span> <span class="n">x</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>The thread macro pattern doesn’t have as much of a place in Scala, since Scala has mechanisms like the collection
library and implicit conversions to help express similar logic in elegant ways.  But when I first read up on macros in
lisp, I spent some time scratching my head at the day-to-day practical uses until I found this and had my first
“ohhhhhhhhhhhh” moment.  In any case, hope this was mildly interesting!</p>




<p>* - Well technically, as the second item in the form, which is effectively the first arg for functions&hellip; But that might
be a bit too lispy.</p>




<h3>Bonus</h3>




<p>When I published this email to the internal list, it generated some discussion wherein I learned that there are other
neat features of the same sort like <a href="https://clojuredocs.org/clojure.core/doto">doto</a>, and that they&rsquo;re all just
various derivations of the K combinator.  Of course, googling k-combinators led to a pretty
<a href="http://en.wikipedia.org/wiki/SKI_combinator_calculus">heavy looking wiki page</a>, so I was referred to
<a href="http://combinators.info/">http://combinators.info/</a> , which I have been trying to get through since.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Silver Searcher]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/the-silver-searcher/"/>
    <updated>2015-01-24T11:53:21-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/the-silver-searcher</id>
    <content type="html"><![CDATA[<h3>grep</h3>




<p>This week I’d like to talk about grep.  Grep is a great general-purpose tool and works very well for filtering text in
the middle of a long command chain, but I’ve found it a bit clunky as a codebase search tool.</p>




<p>For example, let’s say you’re sitting in some project and trying to grep for all the places where a function is being
called.  The naïve first attempt would be:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep myFunc</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Except that just hangs, since grep defaults to reading from stdin.  A next attempt might be:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep myFunc .</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Except then grep would complain that . is a directory, which leads to:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep –r myFunc .</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Which finally works, but still leaves a bit to be desired.  The biggest annoyance is that grep will get caught up in
files that you don’t necessarily care about, e.g. Tags files, third-party dependency files, binary files… “Binary file
./lib/default/xxx.jar matches” anyone?</p>




<h3>ag</h3>




<p>Introducing <a href="http://geoff.greer.fm/ag/">ag, the silver searcher</a>!  Ag:</p>




<ul>
<li>Fulfills the above “find this in cwd” use case via a simple, short <code>ag myFunc</code></li>
<li>Is easy to install and super fast</li>
<li>Respects project ignore files: for example, it will ignore the patterns found in your .gitignore</li>
<li>In the case of files that you want in the repo but still don’t want to search, it also supports the use of a .agignore file</li>
<li>Integrates well into other tools: AFAIK there are ag plugins for vim, emacs, and text mate.</li>
</ul>




<p>Fun fact: I was doing the whole <code>grep –r</code> thing for an embarrassingly long time before I bothered to search for a better
workflow.  My initial search turned up ack, which then led to ag.  As far as I can tell, feature-wise they’re
comparable; I eventually settled on ag just ‘cause the command requires less typing.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim % Expansion]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/vim-expansion/"/>
    <updated>2015-01-24T11:52:53-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/vim-expansion</id>
    <content type="html"><![CDATA[<h3>% (Current File Name)</h3>




<p>Another vim tip this week!  This time, it’s about ‘%’, which expands to ‘current file name’.  This is especially useful
in projects with java/scala style directory setups, where your source is approximately 1.5 million folders away from the
project root, but you kind of want to hang around project root for things like ant/sbt/etc to work.  <code>%</code> makes this
easier to work with files in the deeply nested folders while doing this.</p>




<p>Taking a contrived example, instead of doing something like this to <code>git log</code> the file you are currently editing:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:!git log src/main/scala/com/bizo/(…)/Foo.scala</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>You can just do:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:!git log %</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>This is extremely convenient and works everywhere in command line mode (basically, whenever ‘:’ is used), but is also
useful to have if you’re ever writing vim script.  See <code>:h expand</code> for the function to use in vim script, and some other
special keywords.</p>




<p>But wait!  There’s more!</p>




<!-- more -->




<p>Vim also supports file modifiers.  For example, <code>:h</code> gives you the ‘head’ of the file name, i.e. the directory of the
file.  Taking another (contrived) example, you can git add the entire folder containing the file you are editing by
doing something like:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:!git add %:h</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>See <code>:h file-modifiers</code> for more details (and more modifiers).</p>




<h3>Another Convenient Expansion</h3>




<p>I use <code>%:h</code> so often (for example, when I realize I’ve opened a file before creating the directory containing it, or am
editing a file in a directory that doesn’t exist) that I’ve made a shortcut for it in my vimrc:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cnoremap %% &lt;C-R&gt;=expand('%:h').'/'&lt;CR&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>Roughly speaking, it remaps the key chord <code>%%</code> in command line mode to paste from a special register that evals the vim
script inside it, which calls the expand() function.</p>




<p>Long story short, what this allows me to do is do something like:</p>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:!mkdir -p %%</span></code></pre></td></tr></table></div></figure></notextile></div>




<p>And the <code>%%</code> will expand in-place into whatever <code>%:h</code> resolved to.  Not only is this a win because it’s slightly less to
type than %:h, but the expansion also allows you to quickly modify your command on the fly and go up/down a directory if
needed.</p>




<p>And of course, here’s the requisite asciinema with a quick demo of this in action:</p>




<script type="text/javascript" src="https://asciinema.org/a/14592.js" id="asciicast-14592" async></script>




<p>Hope that’s useful / mildly interesting!</p>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Totw | alex kuang]]></title>
  <link href="http://alexkuang.github.io/blog/categories/totw/atom.xml" rel="self"/>
  <link href="http://alexkuang.github.io/"/>
  <updated>2015-03-28T16:35:58-04:00</updated>
  <id>http://alexkuang.github.io/</id>
  <author>
    <name><![CDATA[Alex Kuang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thing of the Week: Vim Ctrlp, Plus Bonus Rant]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/28/vim-ctrlp-plus-bonus-rant/"/>
    <updated>2015-01-28T10:09:32-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/28/vim-ctrlp-plus-bonus-rant</id>
    <content type="html"><![CDATA[<p>Normally I don&rsquo;t go too much into plugins, since I don&rsquo;t want to encourage the &ldquo;yeah vim is great, just start with 500
plugins, 490 of which you can probably do without&rdquo; mindset.  But if I were stranded on a deserted server and could pick
only one plugin to install, it would probably be ctrlp.</p>

<p><a href="https://github.com/kien/ctrlp.vim">ctrlp</a> is a fuzzy file finder slash project navigation tool.  As usual it&rsquo;s probably
easier to see a demo before doing any sort of explaining, so here&rsquo;s a quick cast of using ctrlp to navigate the
<a href="https://github.com/zmanio/atmos.git">atmos</a> project.</p>

<script type="text/javascript" src="https://asciinema.org/a/15836.js" id="asciicast-15836" async></script>


<p>So the plugin is activated, predictably, by hitting <code>&lt;ctrl-p&gt;</code> (or firing off the <code>:CtrlP</code> command).  This brings up the
UI, where you can type in a bunch of stuff to search.  The fuzzy finding used is very powerful.  First, you can search
any part of the file path + name and it will work; in the first search I did, I just searched <code>scala</code> which brought up
basically anything under not just <code>src/main/scala</code>, but <code>src/test/scala</code> as well.  This is great for if you&rsquo;re doing a
bit of exploring and want to progressively narrow your results.</p>

<p>The other big point worth noting is that it&rsquo;s fuzzy finding, so you don&rsquo;t have to search contiguous characters.  In the
last example, the search was <code>linearspec</code>, but it still selected <code>LinearBackoffSpec</code>.  In theory, I could probably also
do something like <code>linspecsc</code> (&ldquo;<strong>Lin</strong>earBackoff<strong>Spec</strong>.<strong>sc</strong>ala&rdquo;) and get the same result.  This is crazy powerful,
and makes for some pretty fast workflows.</p>

<p>There are a few other nice features that I won&rsquo;t go too far into, like configurable search domains and easy opening
options (e.g., when I popped the selected file into a <code>vsplit</code> in the last search).  Anyone interested can go dig around
in the repo.</p>

<h3>emacs folks</h3>

<p>I&rsquo;ve been playing around with emacs + evil-mode a lot lately.  The equivalent in emacs, AFAIK, is a combination of
<code>helm</code> and <code>projectile</code>.  Funnily enough, I actually prefer the emacs setup a bit, since the search semantics make more
sense to me, but that&rsquo;s a story for another day&hellip;</p>

<h3>Bonus Philosophical Rant</h3>

<p>On mentioning project navigation, there are inevitably reactions of &ldquo;Oh, what about
<a href="https://github.com/scrooloose/nerdtree">NERDTree</a>? (<a href="http://i.imgur.com/Tzid4.png">screencap</a>)&rdquo;  The problem I have
with NERDTree, and project drawers in general, is that reading is <strong>SLOW</strong>.  What project drawers force you to do is
every time you want to find and open a new file, you have to read down the project tree to find it.  Of course,
directory structures and such can enable speed-reading and make the process a bit faster, but it&rsquo;s still way slow in my
opinion.  Taking a concrete example, the last search for <code>LinearBackoffSpec</code>: With a project drawer, I would have had to
scan through the list of <code>ConstantBackoffSpec</code>, <code>ExponentialBackoffSpec</code>, and so on.  With ctrl-p, I just have to hit
<code>&lt;ctrl-p&gt;linspecsc&lt;enter&gt;</code>, which I can do in the middle of making dinner, with my eyes closed.  Not that I code
regularly in those conditions, <em>ahem</em>&hellip;</p>

<p>I don&rsquo;t have a particularly strong hate for NERDTree, I just feel that given the smooth workflow being available with
the likes of ctrlp and ctags, it sits pretty low in the hierarchy of general project navigation tools.  The one scenario
I could see it being useful is to get a feel for the directory structure in a completely unfamiliar project, but even
then I still prefer the <code>tree</code> command (<code>brew install tree</code> on the mac).  Instead, the extra screen real estate can be
used for stuff like continuously running tests, an extra split for documentation, or a command-line twitter client!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thing of the Week: `gn` in Vim]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/gn-in-vim/"/>
    <updated>2015-01-24T11:53:51-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/gn-in-vim</id>
    <content type="html"><![CDATA[<p>Back to vim this week!  This one might be a bit esoteric&ndash;apologies in advance&ndash;but it’s such a useful feature that I
had to share.</p>

<p><code>gn</code> is a kinda-sorta-but-not-really-motion that selects the matches of the current search pattern.  It’s kind of like
<code>n</code> (go to next match in search), except it also selects the contents of the match in visual mode.  But where it really
shines is when used with operators like <code>c</code> (change), etc to operate on the match.  Quick demo to see it in action,
before continuing:</p>

<script type="text/javascript" src="https://asciinema.org/a/15656.js" id="asciicast-15656" async></script>


<p>So this is nice for a few reasons.  First, it’s neat to be able to operate on just the match of a search.  I remember a
few times before I found <code>gn</code> where I was doing something similar to the demo, tried to use <code>cw</code>, and got mildly annoyed
that I had to retype half the word because the <code>w</code> motion was too aggressive.</p>

<p>Another nice thing is that with <code>gn</code>, the dot command will both move to the next match and repeat whatever operation you
did, instead of having to do the movement and operation separately using <code>n.</code>.  It seems petty, but hey it’s a full 50%
keystroke savings!!</p>

<p>Arguably, the demo above could have been done with an ex command like <code>:%s/test/actual</code> (universal search and replace),
but I think <code>gn</code> still offers a lot.  It works on all operators, so <code>ygn</code> would yank the match, <code>gUgn</code> would uppercase
the match, and so on.  Plus, it allows an easy on-the-fly workflow that’s still decently fast without the “crap I have
to tune all the edge cases in my expression”: for example, if you want to only change some instances of <code>test</code> to
<code>actual</code>, but others to <code>sandbox</code>.</p>

<p>As always, see <code>:h gn</code> for more details.  Also note that gn has only been available since vim 7.4 or something like
that, but there’s no reason anyone shouldn’t be using the latest on their personal boxes…</p>

<h3>Bonus</h3>

<p>This email also generated some additional discussion, which led to my discovery of the multi-select feature in Sublime,
and the <a href="https://github.com/terryma/vim-multiple-cursors">associated vim plugin</a>.  It seems like it&rsquo;s in a different
spirit than <code>gn</code>, but still a very cool way of thinking about operating on search results that I had not seen before.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thing of the Week: Thread Macro (01/07/15)]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/thread-macro/"/>
    <updated>2015-01-24T11:53:42-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/thread-macro</id>
    <content type="html"><![CDATA[<p>Let’s deviate from Scala for a bit and talk about clojure.  Or lisps in general, I guess.  A lot of the “kinda joking
except not really” quips that commonly float around on the internet are about the parentheses, as in how there are so
many of them.  For example, if you want to take a number <code>x</code> and add one, multiply by two, then add 3, the code might
naively look something like this:</p>

<pre><code class="clojure">(+ (* (+ x 1) 2) 3)
</code></pre>

<p>Or perhaps like this:</p>

<pre><code class="clojure">(+ 3 (* 2 (+ 1 x)))
</code></pre>

<p>Look at the parens!  Especially the consecutive 3 closing ones in the second variation.  For a sufficiently long chain
of functions, it can get pretty unreadable—especially with multiple arguments and whatnot.</p>

<p>Enter clojure’s thread macro.  The thread macro is a macro in the form of <code>(-&gt; x &amp; forms)</code>, and it “threads” <code>x</code> through
the <code>forms</code> as the first arg*.  Which sounds terribly confusing explained, so an example is probably better here.  Take
this snippet using the thread macro:</p>

<pre><code class="clojure">;; add one, multiply by two, and add three
(-&gt; x
  (+ 1)
  (* 2)
  (+ 3))
</code></pre>

<p>This desugars into <code>(+ (* (+ x 1) 2) 3)</code>, i.e. the first variation of the initial example above.  Personally, I find the
macro version much more readable since each call is on its own line, and it seems more expressive of applying a series
of functions to the initial x.</p>

<p>The thread macro is also useful for chaining together collection methods like <code>map</code>.  Since clojure doesn’t have
first-class OO support (instead favoring protocols and such), map exists as a regular function that takes the collection
as an arg, instead of as a method on a collection class.  So chaining together a bunch of ops on a vector might look
something like&hellip;</p>

<pre><code class="clojure">;; add one to every number and filter for even numbers
(-&gt;&gt; [1 2 3 4 5 6]
  (map #(+ 1 %))
  (filter even?))

;; Without the thread macro, would look like:
(filter even? (map #(+ 1 %) [1 2 3 4 5 6]))
</code></pre>

<p>The only difference is that in this case, ->> was used.  ->> is “thread last”, which is like -> (“thread first”), except
it inserts the expression at the end of the form.</p>

<p>This pattern also exists in other languages (especially those that don’t offer first-class OO, which allows fancy
<code>return self</code> type stuff), like Elixir’s pipe <code>|&gt;</code> (in the spirit of the unix pipe) which is what prompted me to spread
the word about this:</p>

<pre><code class="elixir"># double and add one to each element
[1, 2, 3]
|&gt; Enum.map(fn x -&gt; x * 2)
|&gt; Enum.map(fn x -&gt; x + 1)
</code></pre>

<p>The thread macro pattern doesn’t have as much of a place in Scala, since Scala has mechanisms like the collection
library and implicit conversions to help express similar logic in elegant ways.  But when I first read up on macros in
lisp, I spent some time scratching my head at the day-to-day practical uses until I found this and had my first
“ohhhhhhhhhhhh” moment.  In any case, hope this was mildly interesting!</p>

<p>* - Well technically, as the second item in the form, which is effectively the first arg for functions&hellip; But that might
be a bit too lispy.</p>

<h3>Bonus</h3>

<p>When I published this email to the internal list, it generated some discussion wherein I learned that there are other
neat features of the same sort like <a href="https://clojuredocs.org/clojure.core/doto">doto</a>, and that they&rsquo;re all just
various derivations of the K combinator.  Of course, googling k-combinators led to a pretty
<a href="http://en.wikipedia.org/wiki/SKI_combinator_calculus">heavy looking wiki page</a>, so I was referred to
<a href="http://combinators.info/">http://combinators.info/</a> , which I have been trying to get through since.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thing of the Week: keybase.io (12/24/14)]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/keybase-dot-io/"/>
    <updated>2015-01-24T11:53:30-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/keybase-dot-io</id>
    <content type="html"><![CDATA[<p>Since it&rsquo;s nearly the holidays, I figured something more frivolous would be good for this week.</p>

<p><a href="https://keybase.io/">keybase.io</a> is a combination public key store slash centralized identity slash hipster social
network app.  How it works is that you generate a key pair and upload the public key to their store.  From there, you
can use your key pair to sign messages and post them on twitter, github, bit coin sites, etc, to verify that those
accounts actually belong to you.  At the end of it, you get a funny page like this saying that “why yes, all of these
accounts are crypto-verified to be the same person”, like this:  <a href="https://keybase.io/alexkuang">https://keybase.io/alexkuang</a></p>

<p>It’s still very much in toy app status at the moment, but I think it’s a really cool idea.  I believe they’re open for
signup now; not sure if there’s a beta line or something, but apparently I have invites if anyone wants.</p>

<p>Happy holidays!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thing of the Week: The Silver Searcher (12/17/14)]]></title>
    <link href="http://alexkuang.github.io/blog/2015/01/24/the-silver-searcher/"/>
    <updated>2015-01-24T11:53:21-05:00</updated>
    <id>http://alexkuang.github.io/blog/2015/01/24/the-silver-searcher</id>
    <content type="html"><![CDATA[<h3>grep</h3>

<p>This week I’d like to talk about grep.  Grep is a great general-purpose tool and works very well for filtering text in
the middle of a long command chain, but I’ve found it a bit clunky as a codebase search tool.</p>

<p>For example, let’s say you’re sitting in some project and trying to grep for all the places where a function is being
called.  The naïve first attempt would be:</p>

<pre><code>grep myFunc
</code></pre>

<p>Except that just hangs, since grep defaults to reading from stdin.  A next attempt might be:</p>

<pre><code>grep myFunc .
</code></pre>

<p>Except then grep would complain that . is a directory, which leads to:</p>

<pre><code>grep –r myFunc .
</code></pre>

<p>Which finally works, but still leaves a bit to be desired.  The biggest annoyance is that grep will get caught up in
files that you don’t necessarily care about, e.g. Tags files, third-party dependency files, binary files… “Binary file
./lib/default/xxx.jar matches” anyone?</p>

<h3>ag</h3>

<p>Introducing <a href="http://geoff.greer.fm/ag/">ag, the silver searcher</a>!  Ag:</p>

<ul>
<li>Fulfills the above “find this in cwd” use case via a simple, short <code>ag myFunc</code></li>
<li>Is easy to install and super fast</li>
<li>Respects project ignore files: for example, it will ignore the patterns found in your .gitignore</li>
<li>In the case of files that you want in the repo but still don’t want to search, it also supports the use of a .agignore file</li>
<li>Integrates well into other tools: AFAIK there are ag plugins for vim, emacs, and text mate.</li>
</ul>


<p>Fun fact: I was doing the whole <code>grep –r</code> thing for an embarrassingly long time before I bothered to search for a better
workflow.  My initial search turned up ack, which then led to ag.  As far as I can tell, feature-wise they’re
comparable; I eventually settled on ag just ‘cause the command requires less typing.</p>
]]></content>
  </entry>
  
</feed>
